#!/usr/bin/env python

import rospy
from std_msgs.msg import Int32
from geometry_msgs.msg import PolygonStamped, Point32, TransformStamped, PoseStamped
import tf2_ros
import time

# TODO: timer to publish frame and outline
# TODO: make yaml file
# TODO: make launch file
# TODO: add in python files to CMakeLists

'''
state_machine_rf_welding.py
Alex Elias

Enables/disables robots when they move in a line
Robots get disabled when they get too close to the workspace boundary or each other
Robots get enabled when they get too far from the other enabled robots

Parameters:
    robot_desired_tf_frame_names: list of tf_frames (in tf topic) of robot desired positions,
        ordered "top" to "bottom"
    robot_order: list of numbers 0, 1, ..., N-1 of robots as they appear in swarm controller
        e.g. if 3 is in position 0, this means robot_desired_tf_frame_names[3]
        is the 0th robot in the swarm controller

    min_dist: minimum distance allowed robot-to-robot and robot-to-boundary
    max_dist: maximum distance allowed robot-to-robot

    workspace_frame_vel_topic_name:
    x_top_vel_topic_name:
    x_bottom_vel_topic_name:

    keyboard_vel_cmd_topic_name:
    robot_enable_topic_name:

    swarm_tf: swarm frame(for syncing)
    robot_tf_frame_names: actual (fused) robot position tf_frames (for syncing) in the same order as robot_desired_tf_frame_names
    tf_changer_topic_name: 

'''

MAX_TIMESTEP = 0.1 # For velocity integration
WORKSPACE_HALF_WIDTH = 1.0 # m

class State_machine():
    def __init__(self, N_robots, min_dist, max_dist)):
        self.N_robots = N_robots
        self.state = 0
        self.min_dist = min_dist
        self.max_dist = max_dist

    def transition(self, x_top, x_bottom, x_robots, v_x):
        '''
        "top" robot is robot 0
        "bottom" robot is robot N-1
        coordinate system points from "bottom" to "top" 
        positive state: some "top" robots disabled
        negative state: some "bottom" robots disabled

        Inputs:
            x_top: position of top workspace boundary
            x_bottom: position bot bottom workspace boundary
            x_robots: list of robot positions
            v_x: velocity of swarm
        
        Outputs: 
            Boolean list of robot enable status (True = Enabled)
            Index of newly enable robot
        '''

        new_robot = None

        if self.state == 0:
            # All robots are enabled
            # Just watch for top and bottom robots hitting boundary
            if x_top - x_robots[0] < self.min_dist:
                self.state = 1
            elif x_robots[N_robots-1] - x_bottom < self.min_dist:
                self.state = -1
        
        elif self.state == N_robots:
            # All robots are disabled
            # Waiting for "downward" velocity
            if v_x < 0:
                self.state -= 1
                new_robot = N_robots - 1
        
        elif self.state == -N_robots:
            # All robots are disabled
            # Waiting for "upwards" velocity
            if v_x > 0:
                self.state += 1 
                new_robot = 0
        
        elif self.state > 0:
            # Some top robots are disabled

            # Robot gets disabled if too close
            if x_robots[self.state-1] - x_robots[self.state] < self.min_dist:
                self.state += 1

            # Robot gets enabled if too far
            if x_robots[self.state-1] - x_robots[self.state] > self.max_dist:
                self.state -= 1
                new_robot = self.state
        else: # self.state < 0
            # Some bottom robots are enabled

            # Robot gets disabled if too close
            if x_robots[self.N_robots+self.state-1] - x_robots[self.N_robots+self.state] < self.min_dist:
                self.state -= 1

            # Robot gets enabled if too far
            if x_robots[self.N_robots+self.state-1] - x_robots[self.N_robots+self.state] > self.max_dist:
                self.state += 1
                new_robot = N_robots - 1 + self.state
        
        if self.state > 0:
            status_array =  [False] * self.state + [True] * (self.N_robots-self.state)
        else:
            status_array = [True] * (self.N_robots-(-self.state)) + [False] * (-self.state)

        return status_array, new_robot


class State_machine_ROS_node():
    def __init__(self):
        rospy.init_node('state_machine', anonymous=False)

        # Read in parameters
        self.robot_desired_tf_frame_names = rospy.get_param('~robot_desired_tf_frame_names')
        self.robot_order                  = rospy.get_param('~robot_order')
        min_dist                          = rospy.get_param('~min_dist')
        max_dist                          = rospy.get_param('~max_dist')

        workspace_frame_vel_topic_name = rospy.get_param('~workspace_frame_vel_topic_name') 
        x_top_vel_topic_name           = rospy.get_param('~x_top_vel_topic_name')
        x_bottom_vel_topic_name        = rospy.get_param('~x_bottom_vel_topic_name')

        keyboard_vel_cmd_topic_name    = rospy.get_param('~keyboard_vel_cmd_topic_name')
        robot_enable_topic_name        = rospy.get_param('~robot_enable_topic_name')

        self.swarm_tf                  = rospy.get_param('~swarm_tf')
        self.robot_tf_frame_names      = rospy.get_param('~robot_tf_frame_names')
        tf_changer_topic_name          = rospy.get_param('~tf_changer_topic_name')

        # Initialize
        self.N_robots = len(self.robot_desired_tf_frame_names)
        self.state_machine = State_machine(self.N_robots, min_dist, max_dist)

        self.last_timestep_requests = {}

        self.workspace_outline_seq = 0

        self.x_top = 1.0 # m
        self.x_bottom = -1.0 # m
        self.workspace_center = [0 0 0] # [m m rad]

        # Publish
        self.enable_pub            = rospy.Publisher(robot_enable_topic_name, Int32,          queue_size=10)
        self.workspace_outline_pub = rospy.Publisher("workspace_outline",     PolygonStamped, queue_size=10)
        self.tf_changer_pub        = rospy.Publisher(tf_changer_topic_name,   PoseStamped,    queue_size=10)
        self.tf_broadcaster = tf2_ros.TransformBroadcaster()

        # Subscribe
        rospy.Subscriber(keyboard_vel_cmd_topic_name,       Twist, self.keyboard_vel_callback,        queue_size=1)
        rospy.Subscriber(workspace_frame_vel_topic_name,    Twist, self.workspace_frame_vel_callback, queue_size=1)
        rospy.Subscriber(x_top_vel_topic_name,              Twist, self.x_top_vel_vel_callback,       queue_size=1)
        rospy.Subscriber(x_bottom_vel_topic_name,           Twist, self.x_bottom_vel_callback,        queue_size=1)
        self.tf_listener = tf2_ros.TransformListener()

        # Timers
        rospy.Timer(rospy.Duration(0.01), publish_frames_callback)

    def send_enable_status(status_array):
        msg = int32()
        for i in range(self.N_robots):
            if status_array[i]:
                msg.data += pow(2, self.robot_order[i])
        self.enable_pub.publish(msg)

    def send_workspace_outline(self):
        msg = PolygonStamped()
        self.workspace_outline_seq += 1;

        msg.header.seq = self.workspace_outline_seq
        msg.header.stamp = rospy.Time.now()
        msg.header.frame_id = "workspace"

        msg.polygon.points = [Point32(x = self.x_top,    y =  WORKSPACE_HALF_WIDTH, z = 0.0), # top left
                              Point32(x = self.x_top,    y = -WORKSPACE_HALF_WIDTH, z = 0.0), # top right
                              Point32(x = self.x_bottom, y = -WORKSPACE_HALF_WIDTH, z = 0.0), # bot right
                              Point32(x = self.x_bottom, y =  WORKSPACE_HALF_WIDTH, z = 0.0)] # bot left

        self.workspace_outline_pub.publish(msg)

    def send_workspace_frame(self):
        msg = xyt2TF(self.workspace_center, "map", "workspace")
        self.tf_broadcaster.sendTransform(msg)

    def self.keyboard_vel_callback(self, data):
        v_x = data.linear.x; # TODO: what frame is the keyboard velocity in?

        # Find the robot x locations in the workspace frame
        x_robots = [0.0] * self.N_robots
        for i in range(N_robots)
            #t = self.tf_listener.getLatestCommonTime("workspace",self.robot_deesired_tf_frame_names[i],)
            trans, quaternions = self.tf_listener.lookupTransform("workspace",self.robot_desired_tf_frame_names[i], rospy.Time(0))
            x_robots[i] = trans[0]

        status_array, new_robot = self.state_machine.transition(self.x_top, self.x_bottom, x_robots, v_x)

        if new_robot is not None:
            self.sync_robot(new_robot)

        self.send_enable_status(status_array)

    def sync_robot(self, n_robot):
        if self.tf.frameExists(self.swarm_tf) and self.tf.frameExists(self.robot_tf_frame_names[n_robot]):
            #t = self.tf.getLatestCommonTime(self.robot_tf_frame_names[n_robot], self.swarm_tf)
            trans, quaternions = self.tf.lookupTransform(self.swarm_tf,self.robot_tf_frame_names[n_robot],rospy.Time(0))
            p1 = PoseStamped()
            p1.header.frame_id = self.robot_tf_frame_names[n_robot]
            
            p1.pose.position.x = float(trans[0])
            p1.pose.position.y = float(trans[1])
            p1.pose.position.z = float(trans[2])
            p1.pose.orientation.x = float(quaternions[0])
            p1.pose.orientation.y = float(quaternions[1])
            p1.pose.orientation.z = float(quaternions[2])
            p1.pose.orientation.w = float(quaternions[3])
            #p_in_base = self.tf.transformPose("/base_link", p1)
            self.tf_changer_pub.publish(p1)

    def get_timestep(self, integrator_name):
        current_time = time.time()
        if integrator_name in self.last_timestep_requests:
            dt = current_time - self.last_timestep_requests[integrator_name]
            self.last_timestep_requests[integrator_name] = current_time
            if dt > MAX_TIMESTEP:
                dt = 0.0
            return dt
        else:
            self.last_timestep_requests[integrator_name] = current_time
            return 0.0

    def self.workspace_frame_vel_callback(self, data):
        dt = get_timestep("workspace_frame_vel")
        self.workspace_center[0] += data.linear.x * dt
        self.workspace_center[1] += data.linear.y * dt
        self.workspace_center[2] += data.angular.z * dt

    def self.x_top_vel_callback(self, data):
        dt = get_timestep("x_top_vel")
        self.x_top += data.linear.x * dt

    def self.x_bottom_vel_callback(self, data):
        dt = get_timestep("x_bottom_vel")
        self.x_bottom += data.linear.x * dt

    def publish_frames_callback(self, event):
        self.send_workspace_frame()
        self.send_workspace_outline()


def xyt2TF(xyt, header_frame_id, child_frame_id):
    '''
    Converts a list [x y theta]
    into a tf2_msgs.msg.TFMessage message
    '''
    t = TransformStamped()

    t.header.frame_id = header_frame_id
    t.header.stamp = rospy.Time.now()
    t.child_frame_id = child_frame_id
    t.transform.translation.x = xyt[0]
    t.transform.translation.y = xyt[1]
    t.transform.translation.z = 0

    q = tf_conversions.transformations.quaternion_from_euler(0, 0,xyt[2])
    t.transform.rotation.x = q[0]
    t.transform.rotation.y = q[1]
    t.transform.rotation.z = q[2]
    t.transform.rotation.w = q[3]

    return t

if __name__ == '__main__':
    node = State_machine_ROS_node()
    rospy.spin()    